#+TITLE: Hop's Emacs config
#+AUTHOR: Eric Hopkins
#+EMAIL: eric.on.tech@gmail.com

* Preamble
  Hi there! If you're reading this it's probably because I pointed you here
  after showing some interest or just curiosity in Emacs. This file is written
  in =org-mode=, a markdown-like format.

  I've done a literate programming sort of thing here. There's lots of text
  blocks surrounding code. There are notes to myself, explanations of cryptic
  bits, calling out interesting parts for people who want to learn, etc.

  If you're curious I hope you find my config file helpful!

* Fundamental stuff
  "Fundamental" in the sense that it's just about Emacs here, couldn't think of
  a better heading to be honest.

** Other files and directories
   I have this directory for stuff that I didn't write. Let's make sure that it
   gets loaded up
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'load-path "~/.emacs.d/vendor/")
   #+END_SRC

   By default, Emacs will do something kind of annoying and palace a bunch of
   stuff from ~customize~ at the bottom of [[file:init.el][init.el]].
   Doing this will put it in it's own file.
   #+BEGIN_SRC emacs-lisp
     (setq custom-file "~/.dotfiles/emacs/custom.el")
     ;; Emacs will throw an error if it tries to load a file that doesn't exists
     (shell-command "touch %s" custom-file)
     (load custom-file)
   #+END_SRC

** Enable and customize features
   By default Emacs tries to protect you from some of it's "weirder"
   functionalities, which is honestly funny considering most uninitiated people
   would consider the "weirder parts" all of Emacs. And besides, I know what I'm
   doing. I'm pretty sure there are a few others, But I've never used them.
   #+BEGIN_SRC emacs-lisp
     (put 'narrow-to-region 'disabled nil)
     (put 'downcase-region 'disabled nil)
     (put 'upcase-region 'disabled nil)
   #+END_SRC

   Emacs has two prompts "yes or no" or "y or n". There's no reason to have to
   type out "yes" and "no" all the time. Just use "y" and "n".
   #+BEGIN_SRC emacs-lisp
     (fset 'ejh/default-yes-or-no-p 'yes-or-no-p)
     (fset 'yes-or-no-p 'y-or-n-p)
   #+END_SRC

   All the bells and stuff are just as annoying in Emacs as they are in Vim.
   #+BEGIN_SRC emacs-lisp
     (setq ring-bell-function 'ignore)
   #+END_SRC

** Whitespace settings
   Never use tab characters unless a mode calls for it.
   #+BEGIN_SRC emacs-lisp
     (setq-default indent-tabs-mode nil)
   #+END_SRC

   On the subject of whitespace, Emacs' default settings are [[https://www.emacswiki.org/emacs/TabsAreEvil#toc3][...not good]]. So
   this will make sure that they're in a better default state.
   #+BEGIN_SRC emacs-lisp
     (setq tab-width 4
           c-basic-offset 4 ; not just for C, a lot of Emacs modes reference this
           cperl-indent-level 4)
   #+END_SRC

** Performance settings
   This will help Emacs be snappier, and load faster. It adjusts the amount of
   bytes allocated before it will start running garbage collection. It's default
   setting is *really* low, so it will be constantly throwing information out of
   cache. I have it set to 100MB, on a decently modern, high-power computer, I
   don't notice any lag. Setting it too high *will* cause it to hang while GC
   runs though.
   #+BEGIN_SRC emacs-lisp
     (defvar ejh/default-gc-cons-threshold gc-cons-threshold)
     (setq gc-cons-threshold 100000000)
   #+END_SRC

** Generic functions
   A crappy function that I wrote for when a package, usually a minor-mode of
   some kind that doesn't have a function to invoke it globally.
   #+BEGIN_SRC emacs-lisp
     (defun ejh/globalize (mode)
       "Janky function to make global modes when one isn't provided.
     MODE is the mode to rig a global mode for."
       (add-hook 'prog-mode-hook mode))
   #+END_SRC

   Frequently enough I have to do something /or/ skip something for a specific
   operating system (looking at you Windows). However Emacs has some really
   strange names for them For example Windows is =windows-nt= and BSD is
   =berkeley-unix=. So I make some nice wrappers for them.
   #+BEGIN_SRC emacs-lisp
     (defmacro ejh/when-os-do (name os &optional upcase-p)
         "Create a function with `NAME' that is run only when on `OS'.
       If `UPCASE-P' is not nil, `OS' will be upcase rather than capitalized in the doc string."
         (let ((new-func (intern (format "ejh/when-%s-do" name)))
               (doc-name (if upcase-p
                             (upcase name)
                           (capitalize name))))
           `(defun ,new-func (thing)
              ,(format "Does the `THING' if the device is %s." doc-name)
              (when (string-equal system-type ,os) thing))))

       (defmacro ejh/unless-os-do (name os &optional upcase-p)
         "Create a function with `NAME' that is not run when on `OS'.
       If `UPCASE-P' is not nil, `OS' will be upcase rather than capitalized in the doc string."
         (let ((new-func (intern (format "ejh/unless-%s-do" name)))
               (doc-name (if upcase-p
                             (upcase name)
                           (capitalize name))))
           `(defun ,new-func (thing)
              ,(format "Does `THING' unless the device is %s." doc-name)
              (unless (string-equal system-type ,os) thing))))

       (ejh/when-os-do "osx" "darwin" t)
       (ejh/when-os-do "linux" "gnu/linux")
       (ejh/when-os-do "windows" "windows-nt")
       (ejh/when-os-do "bsd" "berkeley-unix" t)
       (ejh/when-os-do "cygwin" "cygwin")
       (ejh/when-os-do "gnu" "gnu" t)

       (ejh/unless-os-do "osx" "darwin" t)
       (ejh/unless-os-do "linux" "gnu/linux")
       (ejh/unless-os-do "windows" "windows-nt")
       (ejh/unless-os-do "bsd" "berkeley-unix" t)
       (ejh/unless-os-do "cygwin" "cygwin")
       (ejh/unless-os-do "gnu" "gnu" t)
   #+END_SRC

** Setup packages
   Configure where to get packages from, and what priority to give
   them.
   #+BEGIN_SRC emacs-lisp
     (require 'package)
     (setq package-enable-at-startup nil)

     (setq package-archives
           '(("elpa"         . "http://elpa.gnu.org/packages/")
             ("melpa"        . "http://melpa.org/packages/")
             ("melpa-stable" . "http://stable.melpa.org/packages/"))
             ;; ("marmalade"    . "http://marmalade-repo.org/packages/")
           package-archive-priorities
           '(("melpa"        . 10)  ; "I too, like to live dangerously"
             ("melpa-stable" . 5)   ; The safe bet
             ("elpa"         . 3)))   ; The standard
             ;; ("marmalade"    . 0) ; Probably a bad sign if it gets here

     (package-initialize)
   #+END_SRC

   Make sure that =use-package= is installed if it isn't already.
   #+BEGIN_SRC emacs-lisp
     (unless (package-installed-p 'use-package)
       (package-refresh-contents)
       (package-install 'use-package))

     (require 'use-package)
   #+END_SRC

** Setup my personal info
   Let's make sure my personal information is setup. This will effect inserts
   into change logs, note taking, stuff like that.
   #+BEGIN_SRC emacs-lisp
     (setq user-full-name "Eric Hopkins"
           user-mail-address "eric.on.tech@gmail.com"
           calendar-latitude 42.33
           calendar-logitude -83.04
           calendar-location-name "Detroit, MI")
   #+END_SRC

** Spell checking
   On startup, let's see if the underlying system is setup to do any
   spellchecking.
   #+BEGIN_SRC emacs-lisp
     (setq ejh/can-spellcheck-p (if (or (executable-find "aspell")
                                        (executable-find "ispell"))
                                    t
                                  nil))
   #+END_SRC

   If =aspell= exists on the system, it should be preferred over =ispell=.
   #+BEGIN_SRC emacs-lisp
     (if (executable-find "aspell")
         (setq ispell-program-name "aspell"
               ispell-list-command "--list"))
   #+END_SRC

* Visuals
** OS Tuning
   OSX (or macOS, whatever), being the bastard UNIX that it is, gets a lot of
   stuff wrong. It has this weird color error that this fixes.
   #+BEGIN_SRC emacs-lisp
     (ejh/when-osx-do
       (setq ns-use-srgb-colorspace nil))
   #+END_SRC

** GUI stuff
   Let's get rid of all this extra crap.
   #+BEGIN_SRC emacs-lisp
     (menu-bar-mode -1)        ; this can always be turned off, GUI or terminal
     (when (display-graphic-p) ; if we're in a GUI, turn this off too
       (tool-bar-mode -1)
       (toggle-scroll-bar -1))
   #+END_SRC

** Compile buffers
   Back when Emacs was young, it would be strange for a compiler to produce
   output that used escape sequences for color. Obviously that's not the case
   now, so this will help make sure that Emacs can show color in a ~*compile*~
   buffer rather than showing all the literal escape sequences.
   #+BEGIN_SRC emacs-lisp
     (require 'ansi-color)

     (defun ejh/ansi-colorize-buffer ()
       (let ((buffer-read-only nil))
         (ansi-color-apply-on-region (point-min) (point-max))))
     (add-hook 'compilation-filter-hook 'ejh/ansi-colorize-buffer)
   #+END_SRC

** Fonts
   I tend to change this a lot, right now I'm partial to Google's new monospaced
   font "Noto Sans Mono" (not to be confused with "Noto Mono").
   #+BEGIN_SRC emacs-lisp
     (setq ejh/env-emacs-font (getenv "EMACS_FONT"))
     (setq ejh/env-emacs-font-size (getenv "EMACS_FONT_SIZE"))
     (setq ejh/default-font (if ejh/env-emacs-font
                                ejh/env-emacs-font
                              "monospace"))
     (setq ejh/default-font-size (if ejh/env-emacs-font-size
                                     (string-to-number ejh/env-emacs-font-size)
                                   12))
     (setq ejh/current-font-size ejh/default-font-size)
     (setq ejh/font-change-increment 1)

     (defun ejh/font-code ()
       "Returns a string representing the current font"
       (concat ejh/default-font "-" (number-to-string ejh/current-font-size)))

     (defun ejh/set-font-size ()
       "Set the font to `ejh/default-font' at `ejh/current-font-size'.
     Set that for the current frame, and also make it the default for
     other, future frames."
       (let ((font-code (ejh/font-code)))
         (add-to-list 'default-frame-alist (cons 'font font-code))
         (set-frame-font font-code)))

     (defun ejh/reset-font-size ()
       "Change font size back to `ejh/default-font-size'."
       (interactive)
       (setq ejh/current-font-size ejh/default-font-size)
       (ejh/set-font-size))

     (defun ejh/increase-font-size ()
       "Increase current font size by a factor of `ejh/font-change-increment'."
       (interactive)
       (setq ejh/current-font-size
             (ceiling (+ ejh/current-font-size ejh/font-change-increment)))
       (ejh/set-font-size))

     (defun ejh/decrease-font-size ()
       "Decrease current font size by a factor of `ejh/font-change-increment'."
       (interactive)
       (setq ejh/current-font-size
             (max 1
                  (floor (- ejh/current-font-size ejh/font-change-increment))))
       (ejh/set-font-size))

     (ejh/reset-font-size)
   #+END_SRC

** Pretty icons, Modeline, File explorer, and ~dired~
   This is where I make Emacs look a lot more modern. For starters, most of the
   cool new editors have icons for files, not only does this look good, but it's
   pretty helpful to boot. ~all-the-icons~ is an Emacs package that combines all
   of the great icon fonts out there.
   #+BEGIN_SRC emacs-lisp
     (use-package all-the-icons)
   #+END_SRC
   The next step is pretty easy, to get them into ~dired~ there's a package that
   does just that.
   #+BEGIN_SRC emacs-lisp
     (use-package all-the-icons-dired
       :init
       (require 'font-lock)
       (require 'font-lock+) ; This comes from the ./vendor/ directory
       :after (all-the-icons)
       :config (if (display-graphic-p)
                   (add-hook 'dired-mode-hook 'all-the-icons-dired-mode)))
   #+END_SRC
   Next up is setting up a file tree. I'm actually not a huge fan of these, but
   for projects in particular languages it can be helpful to get a "lay of the
   land" so to speak.
   #+BEGIN_SRC emacs-lisp
     (use-package neotree
       :config
       (setq neo-theme (if (display-graphic-p)
                           'icons
                         'arrow)))
   #+END_SRC

* Package configuration
** ~use-package~ bootstrapping
   First things first! My config uses the great =use-package=. Among the many
   things it can do, if it runs across something that isn't installed it can go
   and get it, but rather than typing =:ensure t= all over the place this
   setting will do it for everything.

   There's one snag doing it this way. ~use-package~ can be used on built-in
   packages, but naturally "ensuring" them doesn't make sense, and leads to
   errors. If this is set, ~use-package~ calls for built-ins need to say
   ~:ensure nil~.
   #+BEGIN_SRC emacs-lisp
     (setq use-package-always-ensure t)
   #+END_SRC

   ~use-package~ has it's own plugin system. This adds one that allows for
   interaction with the OS's package manager. One stop closer to being able to
   bootstrap an entire system via Emacs.
   #+BEGIN_SRC emacs-lisp
     (use-package system-packages)
     (use-package use-package-ensure-system-package
       :after (system-packages))
   #+END_SRC

** Language independent
*** Terminal settings
    This will help prevent *really* slow rendering in =term=.
    #+BEGIN_SRC emacs-lisp
      (add-hook 'term-mode-hook
                (lambda ()
                  (setq bidi-paragraph-direction 'left-to-right)))
    #+END_SRC

*** Keybindings / General
    This will make sure ~general~ is there, I'm only going to put a few built in
    commands that wouldn't have anywhere else to go on it here. Now that it's
    available, other ~use-package~ statements can use ~:general~ to set up
    bindings.
    #+BEGIN_SRC emacs-lisp
      ;; I took the idea (or name) of a `leader' and `local-leader' from my Vim days.
      ;; These probably look like *INSANE* bindings, and they would be. Except that I
      ;; use an ErgoDox keyboard. My control key is under my left pinky, and both my
      ;; space and backspace keys are under my left thumb.
      (setq ejh/leader-key "C-c C-SPC")
      (setq ejh/local-leader-key "C-c <C-backspace>")

      (use-package general
        :config
        (general-define-key
         :prefix ejh/leader-key
         "b" '(nil :which-key "buffers")
         "g" '(nil :which-key "git")
         "j" '(nil :which-key "jump")
         "p" '(nil :which-key "project")
         "s" '(nil :which-key "search")
         "sg" '(nil :which-key "git project")
         "t" '(nil :which-key "toggle")
         "tF" '(auto-fill-mode :which-key "fill break")
         "tn" '(linum-mode :which-key "line numbers")
         "tN" '(global-linum-mode :which-key "global line numbers")
         "x" '(nil :which-key "text")))
    #+END_SRC

    These are some really helpful functions I've put together for aligning text,
    I took inspiration for them from Spacemacs, and the Emacs Wiki.
    #+BEGIN_SRC emacs-lisp
      ;; Jocked from http://emacswiki.org/emacs/AlignCommands
      (defun ejh/align-repeat (start end regexp &optional justify-right after)
        "Repeat alignment with respect to the given regular expression.
      START and END are where the selected region starts and ends, and are
      provided to 'align-regexp'.  REGEXP is the character, or expression to be
      aligned.  If JUSTIFY-RIGHT is non-nil justify to the right instead of the
      left. If AFTER is non-nil, add whitespace to the left instead of the right."
        (interactive "r\nsAlign regexp: ")
        (let* ((ws-regexp (if (string-empty-p regexp)
            "\\(\\s-+\\)"
                "\\(\\s-*\\)"))
         (complete-regexp (if after
                  (concat regexp ws-regexp)
                (concat ws-regexp regexp)))
         (group (if justify-right -1 1)))
          (message "%S" complete-regexp)
          (align-regexp start end complete-regexp group 1 t)))

      (defmacro ejh/create-align-x (name regexp &optional justify-right default-after)
        "This will create a new function to align text.
      NAME is the name that will be appended to the created function.  For example
      \"colon\" will produce the function \"ejh/align-repeat-colon\".  REGEXP is the
      character or expression to be aligned.  If JUSTIFY-RIGHT is non-nil, justify to
      the right instead of the left.  If DEFAULT-AFTER is non-nil, add whitespace to
      the left instead of the right."
        (let ((new-func (intern (concat "ejh/align-repeat-" name))))
          `(defun ,new-func (start end switch)
             (interactive "r\nP")
             (let ((after (not (eq (if switch t nil) (if ,default-after t nil)))))
               (ejh/align-repeat start end ,regexp ,justify-right after)))))

      (ejh/create-align-x "colon" ":" nil t)
      (ejh/create-align-x "comma" "," nil t)
      (ejh/create-align-x "equal" "=")
      (ejh/create-align-x "arrow" "->")
      (ejh/create-align-x "back-arrow" "<-")
      (ejh/create-align-x "fat-arrow" "=>")

      (general-define-key
       :prefix ejh/leader-key
       "xf=" '(ejh/align-repeat-equal :which-key "equal")
       "xf:" '(ejh/align-repeat-colon :which-key "colon")
       "xf-" '(ejh/align-repeat-arrow :which-key "arrow")
       "xf>" '(ejh/align-repeat-fat-arrow :which-key "fat arrow")
       "xf<" '(ejh/align-repeat-back-arrow :which-key "back arrow")
       "xf," '(ejh/align-repeat-comma :which-key "comma")
       "xfr" '(align-regexp :which-key "regex"))
    #+END_SRC

*** Evil mode
    I used Vim for ~6 years, and over a period of a year or so, I transitioned
    over to Emacs.
    I had originally tried to use ~evil-mode~, but ultimately felt that it
    didn't mix all that well with Emacs. And, with a good keyboard I don't have
    any issues with RSI.
    I /may/ come back around to the idea of using ~evil-mode~, but for now I'm
    just using regular Emacs.
    #+BEGIN_SRC emacs-lisp
      ;; (use-package evil
      ;;   :commands (evil-mode))
      ;; (evil-mode)
    #+END_SRC

*** Highlight numbers
    I honestly don't know why Emacs doesn't have number highlighting by default,
    here's a little package that puts it in.
    #+BEGIN_SRC emacs-lisp
      (use-package highlight-numbers
        :config (add-hook 'prog-mode-hook 'highlight-numbers-mode))
    #+END_SRC

*** Hungry delete
    This becomes less necessary with =evil-mode= because =C-w= deletes
    whitespace pretty well. But it's still a nice to have.
    #+BEGIN_SRC emacs-lisp
      (use-package hungry-delete
        :general
        ("H-<backspace>" 'hungry-delete-backward)
        (:prefix ejh/leader-key
         "td" '(hungry-delete-mode :which-key "hungry delete")))
    #+END_SRC

*** Google Translate
    Translate blocks of text, right from inside Emacs!
    #+BEGIN_SRC emacs-lisp
      (use-package google-translate)
    #+END_SRC

*** Fill column
    I've been souring on =fill-column-indicator= lately, it interferes with
    =company= quite a bit, among others. I think long term I want to replace it
    with just regular 'ol =whitespace-mode= or something.
    #+BEGIN_SRC emacs-lisp
      (use-package fill-column-indicator)
    #+END_SRC

*** Which key
    This is a crazy helpful minor mode that basically shows completion for key
    chords.
    #+BEGIN_SRC emacs-lisp
      (use-package which-key
        :config (ejh/globalize #'which-key-mode))
    #+END_SRC

*** Magit! & other Git stuff
    The only other complete Git porcelain aside from the Git CLI itself. I
    really have a surprisingly small configuration for it. For how much time I
    invest in Git, I should really learn to do more with Magit.
    #+BEGIN_SRC emacs-lisp
      (use-package magit
        :general
        (:prefix ejh/leader-key
         "gb" '(magit-blame :which-key "blame")
         "gs" '(magit-status :which-key "status")
         "gm" '(magit-dispatch-popup :which-key "menu"))
        :config
        ;; Magit now tries to hide less common things to cut down on potential
        ;; confusion. There are 7 levels in total; I don't want any of it hidden
        (setq transient-default-level 7))

      ;; This is the basic git-gutter. Maybe in the future I'll do something fancier
      ;; like the fringe git-gutter.
      (use-package git-gutter
        :config (global-git-gutter-mode))

    #+END_SRC

*** Ivy / Counsel / Swiper
    This is what lets me search through all sorts of things in Emacs, with a
    fuzzy-finding sort of behavior. It's a lot like a "Command Pallet" in
    several newer editors. =ivy=, =counsel=, and =swiper= all sort of go
    together, though they do slightly different things.
    I use =ivy= instead of =helm= for a bit of a lighter experience. I've liked
    it a lot so far, though I'm not opposed to trying =helm= again at some point
    (I used it for a bit when I was first learning Emacs via Spacemacs).
    #+BEGIN_SRC emacs-lisp
      (use-package ivy
        :config
        (ivy-mode)
        (setq ivy-use-virtual-buffers t
              ivy-count-format "(%d/%d) ")
        :general
        (:prefix ejh/leader-key
         "bb" '(ivy-switch-buffer :which-key "buffers")
         "bk" '(kill-buffer :which-key "kill")))

      (use-package counsel
        :general
        ("M-x" 'counsel-M-x)
        ("C-h v" 'counsel-describe-variable)
        ("C-h f" 'counsel-describe-function)
        (:prefix ejh/leader-key
         "SPC" '(counsel-M-x :which-key "commands")
         "sa"  '(counsel-ag :which-key "ag")
         "sG"  '(counsel-grep :which-key "grep")
         "sr"  '(counsel-rg :which-key "rg")
         "sp"  '(counsel-pt :which-key "pt")
         "tt"  '(counsel-load-theme :which-key "theme")))

      (use-package swiper
        :general
        (:prefix ejh/leader-key
         "ss" '(swiper :which-key "swiper")))
    #+END_SRC

*** Projectile
    =projectile= is what makes working with "projects" really nice. A project
    has a few definitions in Projectile's terminology, but the only one I really
    care about is one that is under version control (i.e. has a =.git/=
    directory, etc).
    Put =ripgrep= in here, it's only meaningful in that context.
    #+BEGIN_SRC emacs-lisp
      (use-package projectile
        :defer nil
        :config
        (projectile-mode)
        (global-set-key (kbd "M-*") 'projectile-run-async-shell-command-in-root)
        (setq frame-title-format '((:eval (projectile-project-name)))))

      ;; I should probably change up my `when-os-do' so that it's an `if'
      ;; rather than a `when'. It would end up being more versitile
      (use-package ripgrep
        :ensure-system-package (rg . ripgrep))

      (use-package counsel-projectile
        :after (counsel projectile)
        :defer nil
        :general
        (:prefix ejh/leader-key
         "pd" '(counsel-projectile-find-dir :which-key "find directory")
         "pf" '(counsel-projectile-find-file :which-key "find file")
         "pp" '(counsel-projectile-switch-project :which-key "switch project")
         "sga" '(counsel-projectile-ag :which-key "ag")
         "sgp" '((message "Write me!") :which-key "pt"))
        :config
        ;; NOTE: This is a hack so that `counsel-projectile' will work after some
        ;; changes were made to the keymaps of `projectile'. This shouldn't be
        ;; necesary for very long. Keep track of:
        ;; https://github.com/ericdanan/counsel-projectile/pull/92
        (defvar counsel-projectile-mode-map
          (let ((map (make-sparse-keymap))
                (projectile-command-keymap (where-is-internal 'projectile-command-map nil t))) ; this..
            (when projectile-command-keymap
              (define-key map projectile-command-keymap 'counsel-projectile-command-map)) ; ..and this are the change.
            (define-key map [remap projectile-find-file] 'counsel-projectile-find-file)
            (define-key map [remap projectile-find-dir] 'counsel-projectile-find-dir)
            (define-key map [remap projectile-switch-to-buffer] 'counsel-projectile-switch-to-buffer)
            (define-key map [remap projectile-grep] 'counsel-projectile-grep)
            (define-key map [remap projectile-ag] 'counsel-projectile-ag)
            (define-key map [remap projectile-switch-project] 'counsel-projectile-switch-project)
            map)
          "Keymap for `counsel-projectile' mode.")
        (counsel-projectile-mode))

      (use-package projectile-ripgrep
        :after (counsel projectile ripgrep)
        :config
        (defun ejh/counsel-projectile-rg (&optional options)
          "Ivy version of `projectile-ripgrep'.
      This is hacked together off the code of `counsel-projectile-ag'.
      `OPTIONS' are CLI options that could be passed to ripgrep."
          (interactive)
          ;; initalize these variables if they aren't set.
          (defvar grep-find-ignored-files)
          (defvar grep-find-ignored-directories)
          (if (projectile-project-p)
              (let* ((options
                      (if current-prefix-arg
                          (read-string "options: ")
                        options))
                     (ignored
                      (unless (eq (projectile-project-vcs) 'git)
                        ;; rg supports git ignored files
                        (append
                         (cl-union (projectile-ignored-files-rel)
                                   grep-find-ignored-files)
                         (cl-union (projectile-ignored-directories-rel)
                                   grep-find-ignored-directories))))
                     (options
                      (concat options " "
                              (mapconcat (lambda (i)
                                           (concat "--ignore " i))
                                         ignored
                                         " "))))
                (counsel-rg nil
                            (projectile-project-root)
                            options
                            (projectile-prepend-project-name "rg: ")))
            (user-error "You're not in a project!")))
        :general
        (:prefix ejh/leader-key
         "sgr" '(ejh/counsel-projectile-rg :which-key "rg")))
    #+END_SRC

*** Avy
    In Vim there's a package called =EasyMotion=, and apparently it's creator
    switched to Emacs over the experience of trying to make that in =VimL=. Avy
    is that in Emacs, but obviously better.
    #+BEGIN_SRC emacs-lisp
      (use-package avy
        :commands (avy-goto-char
                   avy-goto-line
                   avy-goto-line-above
                   avy-goto-line-below
                   avy-goto-word-0)
        :general
        (:prefix ejh/leader-key
         "jc" '(avy-goto-char :which-key "to character")
         "jC" '(avy-goto-char-2 :which-key "to character w/ input")
         "jl" '(avy-goto-line :which-key "to line")
         "jn" '(avy-goto-line-below :which-key "to next line")
         "jp" '(avy-goto-line-above :which-key "to previous line")
         "jw" '(avy-goto-word-0 :which-key "to word")
         "jW" '(avy-goto-word-1 :which-key "to word w/ input")))
    #+END_SRC

*** Multiple Cursors
    I've been meaning to do more with this, but I've never dedicated enough time
    to it. I mean, look at [[http://emacsrocks.com/e13.html][this]]!
    #+BEGIN_SRC emacs-lisp
      (use-package multiple-cursors
        :defer t) ; Not preferable, but not sure what else to defer on
    #+END_SRC

*** Rainbow delimiters
    People mention =org-mode= and =magit= as killer packages that are reasons
    that someone might want to switch to Emacs. This is one of those little
    packages that doesn't change your life; but damn is it nice. I think VS Code
    has something like it, but it doesn't seem to hold up next to Emacs.
    #+BEGIN_SRC emacs-lisp
      (use-package rainbow-delimiters
        :config
        (ejh/globalize #'rainbow-delimiters-mode))
    #+END_SRC

*** Company
    Emacsers loves cutesy names that don't immediately tell you what the package
    actually does. =company= is short for *Comp*-lete *any*-thing. Basically,
    it's my auto-completion.
    #+BEGIN_SRC emacs-lisp
      (use-package company
        :config
        (global-company-mode)
        (global-set-key (kbd "C-S-SPC") 'company-complete)
        ;; This unsets a super weird default where `company' will downcase
        ;; suggestions that come from buffer completion.
        (setq company-dabbrev-downcase nil)
        ;; Have suggestions start after two characters have been typed, not the
        ;; default of three
        (setq company-minimum-prefix-length 2)
        ;; With some languages, particularly statically typed ones, `company's
        ;; suggestion pop-up can get extremely cramped and noisy. Setting this makes
        ;; the formatting a lot cleaner
        (setq company-tooltip-align-annotations t))
    #+END_SRC

*** iedit
    Another entry in the long Emacs tradition of "Names that don't convey what
    the package does", =iedit= allows for editing a bunch of like symbols at
    once. There's some feature overlap with =multiple-cursors= here, but
    whatevs.
    #+BEGIN_SRC emacs-lisp
      (use-package iedit
        :general
        (:prefix ejh/leader-key
                 ";" '(iedit-mode :which-key "iedit")))
    #+END_SRC

*** Stupid indent
    Most of the time, Emacs' smart indentation is great. But when it's wrong,
    *wow* is it wrong. =stupid-indent-mode= will make indentation behave more
    like Vim's (in most cases).
    #+BEGIN_SRC emacs-lisp
      (use-package stupid-indent-mode)
    #+END_SRC

*** Smartparens
    This is one of the better plugins for handling automatic pair insertions

    #+BEGIN_SRC emacs-lisp
      (use-package smartparens
        :config
        ;; By default, smartparens adds this sort of annoying background
        ;; highlighting. Setting it to nil removes it.
        (setq sp-highlight-pair-overlay nil)
        (show-paren-mode)
        (defun ejh/enter-and-indent-sexp (&rest _ignored)
          "Insert an extra newline at point, and re-indent"
          (newline)
          (indent-according-to-mode)
          (forward-line -1)
          (indent-according-to-mode))

        (defmacro ejh/smart-indent-sequence (sequence &optional name end-sequence)
          "Creates functions to intelligently indent after a given `SEQUENCE'.
      If `NAME' is provided, it will be used in place of `SEQUENCE' in the function name that's generated."
          (let ((new-func (intern (format "ejh/smart-indent-%s" (if name
                                                                    name
                                                                  sequence)))))
            `(defun ,new-func (modes)
               ,(format "Intelligently indents after the character sequence of %s in `MODES'." sequence)
               (dolist (mode modes)
                 (sp-local-pair mode ,sequence (if ,end-sequence
                                                   ,end-sequence
                                                 nil) :post-handlers
                                                 '((ejh/enter-and-indent-sexp "RET")
                                                   (ejh/enter-and-indent-sexp "<return>")))))))

        ;; NOTE: not sure how I feel about setting all these values in here, it may be
        ;; better to set each of them in their respective langauge configuration areas
        ;; that way there's not code running for a language that can't be found in
        ;; it's designated area in the configuration file.
        (setq ejh/default-language-list '(c-mode
                                          c++-mode
                                          css-mode
                                          java-mode
                                          js-mode
                                          js2-mode
                                          json-mode
                                          objc-mode
                                          python-mode
                                          ruby-mode
                                          rust-mode
                                          sh-mode
                                          typescript-mode
                                          web-mode))
        (ejh/smart-indent-sequence "{" "curly")
        (ejh/smart-indent-curly ejh/default-language-list)
        (ejh/smart-indent-sequence "[" "bracket")
        (ejh/smart-indent-bracket ejh/default-language-list)
        (ejh/smart-indent-sequence "(" "paren")
        (ejh/smart-indent-paren ejh/default-language-list)
        (ejh/smart-indent-sequence "\"\"\"" "triple-equals" "\"\"\"")
        (ejh/smart-indent-triple-equals '(python-mode)))
    #+END_SRC

*** Highlight Indentation
    A helpful mode for dealing with whitespace sensitive languages, and
    especially YAML files.

    #+BEGIN_SRC emacs-lisp
      (use-package highlight-indent-guides
        :config
        (setq highlight-indent-guides-method 'character))
    #+END_SRC

*** Yasnippets
    ~yasnippets~ is the standard for managing snippets.
    #+BEGIN_SRC emacs-lisp
      (use-package yasnippet
        :config
        (yas-global-mode)
        ;; `company-yasnippet' is provided in `company' itself, but it has to be
        ;; tacked on to the backend using a `:with'. This is all in service of that.
        ;; I _think_ the origin of this code is Spacemacs, but I don't know for sure.
        (defvar ejh/enable-company-yas t
          "Enable yasnippet for all backends.")
        (defun ejh/backend-with-yas (backend)
          "Intended to be used in a map. Takes in each `BACKEND' from a list of
      backends, either `company-backends' or similar. And takes `BACKEND' from
      something like.

      \(company-foo\)
      To:
      \(company-foo :with company-yasnippet\)"
          (if (or (not ejh/enable-company-yas)
                  (and (listp backend)
                       (member 'company-yasnippet backend)))
              backend
            (append (if (consp backend)
                        backend
                      (list backend))
                    '(:with company-yasnippet))))
        (defun ejh/yasnippetify-backends (backends)
          "Take a list of `BACKENDS' and append a `:with' to them for `yasnippet'."
          (mapcar #'ejh/backend-with-yas backends))
        (setq company-backends
              (ejh/yasnippetify-backends company-backends)))
    #+END_SRC

*** Tags
    Emacs' tags situation is a lot wider than what's available in Vim; I'm not
    exactly sure that's a good thing though. It ends up feeling pretty confused
    at times.
    Emacs uses the =ETags= format, =ctags= can create them with the =-e= flag,
    and /most/ other programs seem to handle them well enough (=gotags= is a
    notable exception).
    There's also stuff like =ggtags= which I haven't dug into at all.
    #+BEGIN_SRC emacs-lisp
      (add-hook 'speedbar-mode-hook
                (lambda ()
                  (speedbar-add-supported-extension ".rb")
                  (speedbar-add-supported-extension ".ru")
                  (speedbar-add-supported-extension ".erb")
                  (speedbar-add-supported-extension ".rjs")
                  (speedbar-add-supported-extension ".rhtml")
                  (speedbar-add-supported-extension ".rake")))
    #+END_SRC

*** Flycheck
    Don't have much in mind for this yet. Just want to make sure that
    it's here.
    #+BEGIN_SRC emacs-lisp
      (use-package flycheck)
    #+END_SRC

*** Fun stuff
    Nothing in here exactly matters in the way that other parts of the
    configuration do. But they're pretty cool
**** Get the weather
     This will make use of the =wttrin= API to display the weather in a buffer.
     #+BEGIN_SRC emacs-lisp
       (use-package wttrin ; get the weather in Emacs!
         :commands (wttrin)
         :init
         (setq wttrin-default-cities '("Detroit" "Novi"))
         (setq wttrin-default-accept-language '("Accept-Language" . "en-US"))
         (defun ejh/wttrin-default ()
           "Open `wttrin' without prompting, use the first city in `wttrin-default-cities'."
           (interactive)
           (wttrin-query (car wttrin-default-cities)))
         (defun ejh/wttrin-work ()
           "Open `wttrin' without prompting to get the weather at work."
           (interactive)
           (wttrin-query "Detroit"))
         (defun ejh/wttrin-home ()
           "Open `wttrin' without prompting to get the weather at home."
           (interactive)
           (wttrin-query "Novi")))
     #+END_SRC

** Languages

   This is still *very* much a work in progress. I'm filling these out on an as
   needed basis. I have a file I'm working off of for the packages that I want
   to investigate/add for each of these languages.

*** C Family
*** C#

    I started my development career working as a .NET developer; on VB.NET no
    less! I realize this is an unpopular opinion to have in certain circles, but
    I actually *like* things about languages such as C# and Java. I'm
    particularly impressed with LINQ and what has been done with .NET Core.
    #+BEGIN_SRC emacs-lisp
      (use-package csharp-mode
        :init (add-hook 'csharp-mode-hook
                        (lambda ()
                          (setq-local company-backends
                                      (ejh/yasnippetify-backends '(company-omnisharp
                                                                   company-capf
                                                                   company-files
                                                                   company-dabbrev)))
                          (setq indent-tabs-mode nil
                                c-syntactic-indentation t
                                c-basic-offset 4
                                truncate-lines t
                                ;; NOTE: the new version of `omnisharp' doesn't support
                                ;; this atm. I'm leaving it here for when it starts
                                ;; working again.
                                omnisharp-auto-complete-want-importable-types t
                                tab-width 4
                                stupid-indent-level 4)
                          (company-quickhelp-local-mode +1)
                          (electric-pair-local-mode +1)
                          (c-set-style "c#")
                          (omnisharp-mode +1)
                          (flycheck-mode +1))))
      (use-package omnisharp
        :after (csharp-mode))
    #+END_SRC

*** CSS
*** Cucumber
*** D

    I found ~D~ on a whim one time while practicing some TDD. The idea was to
    try and get through a kata with a language that I'm unfamiliar with. I
    actually walked away thinking it's a pretty cool little language. I'd like
    to dedicate some more time to it eventually.
    #+BEGIN_SRC emacs-lisp
      (use-package d-mode
        :commands d-mode)
    #+END_SRC

*** Dart
*** Docker

    I love Docker, I've actually contributed to the ~docker~ package in
    here. It's good stuff.
    #+BEGIN_SRC emacs-lisp
      (use-package docker
        :config
        ;; Red Hat based distros always need Docker to be run as root. It's not
        ;; perfect, but if any of their package managers are preesent there's a
        ;; 99.9% chance it's RHL based, and needs this.
        (if (or (executable-find "dnf")
                (executable-find "yum"))
            (setq docker-run-as-root t))
        ;; Apparently this is needed because of how Docker needs to be run in a
        ;; virtual machine. Windows might need something similar, but I'll cross
        ;; that bridge when I get there.
        (ejh/when-osx-do (lambda ()
                           (setenv "PATH" (concat (getenv "PATH") ":/usr/local/bin"))
                           (setq exec-path (append exec-path '("/usr/local/bin")))
                           ;; Use "docker-machine env box" command to find out your env variables
                           (setenv "DOCKER_TLS_VERIFY" "1")
                           (setenv "DOCKER_HOST" "tcp://10.11.12.13:2376")
                           (setenv "DOCKER_CERT_PATH" (concat (getenv "HOME") "/.docker/machine/machines/box"))
                           (setenv "DOCKER_MACHINE_NAME" "box"))))
      (use-package dockerfile-mode)
      (use-package docker-compose-mode)
    #+END_SRC

*** Elixir

    Nothing interesting here, The Ruby-ness of Elixir make me pretty interested
    in it. Hoping to get into it more in the future.
    #+BEGIN_SRC emacs-lisp
      (use-package elixir-mode
        :commands (elixir-mode))
    #+END_SRC

*** Elm

    I found Elm around v0.16, right before v0.17 came out and I got really into
    it around that time. I was mostly onboard with v0.18 when that dropped,
    though I thought some changes were dogmatic. Life and work got in the way
    and I drifted. As of writing this paragraph, v0.19 dropped and I'm not so
    interested. It seems to be moving in a direction I don't want to follow.

    I still think Elm is great, but in all honestly, I want to like it more than
    I do. If I still want to do ML in the browser, I think I'm going to focus on
    PureScript or Reason.
    #+BEGIN_SRC emacs-lisp
      (use-package elm-mode
        :mode "\\.elm\\'")
    #+END_SRC

*** Erlang

    #+BEGIN_SRC emacs-lisp
      (use-package erlang)
    #+END_SRC

*** F#

    While it's a bit unorthodox, ~F#~ seems like a really cool ML. It's outlook
    seems to be "be less pure if it gets things done", mostly in a business-y
    context. Less attractive to purists maybe, but it's an interesting approach
    and I'd like to give some more time to it.
    #+BEGIN_SRC emacs-lisp
      (use-package fsharp-mode)
    #+END_SRC

*** Go

    I had more written for my ~go~ configuration, but when I was merging about
    three separate Emacs configs into this ~org-mode~ file, something got lost
    in the move. I haven't had to do any ~go~ sense, so I've left it at the bare
    minimum right now.
    #+BEGIN_SRC emacs-lisp
      (use-package go-mode)
    #+END_SRC

*** Groovy

    #+BEGIN_SRC emacs-lisp
        (use-package groovy-mode
          :defer t) ; My use-case for this is *very* rare
    #+END_SRC

*** Haskell

    Everyone's favorite hobby language. There's so much more I could do with
    this that I haven't yet.
    #+BEGIN_SRC emacs-lisp
      (use-package haskell-mode
        :commands (haskell-mode))
    #+END_SRC

*** Hy
*** Idris
*** Java

    I'm pretty rusty with Java, this isn't much; but I want to set something up
    for some practice. I could still integrate ~eclim~, which lets Emacs
    interact with a headless version of Eclipse. There's also a plugin being
    worked on that allows Emacs to talk to Intellij via LSP (Language Server
    Protocol) and make use of all Intellij's features.
    #+BEGIN_SRC emacs-lisp
      (use-package meghanada
        :commands (meghanada-mode))

      (add-hook 'java-mode-hook
                (lambda ()
                  (setq indent-tabs-mode nil
                        c-basic-offset 4
                        tab-width 4
                        stupid-indent-level 4)
                  (meghanada-mode +1)
                  (flycheck-mode +1)
                  (electric-pair-local-mode +1)
                  (add-hook 'before-save-hook
                            'meghanada-code-beautify-before-save)
                  ;; I don't think this should be neccessary,
                  ;; but it seems to help ¯\_(ツ)_/¯
                  ;; Update: I think this was an `evil-mode' thing. Maybe it's
                  ;; unecessary now?
                  (add-hook 'after-save-hook
                            'meghanada-import-all)
                  (ejh/when-windows-do (setq meghanada-java-path
                                             (expand-file-name "bin/java.exe" (getenv "JAVA_HOME"))
                                             meghanada-maven-path "mvn.cmd"))))
    #+END_SRC

*** JavaScript & friends

    #+BEGIN_SRC emacs-lisp
      (defun ejh/less-annoying-js2 ()
        "`js2-mode' has some annoying defaults that really should be left to something
      like `flycheck'. This turns them off."
        (setq js2-strict-missing-semi-warning nil
              js2-strict-trailing-comma-warning nil
              js2-basic-offset 2))
      (use-package js2-mode
        :config (ejh/less-annoying-js2)
        :commands (js2-mode))

      (use-package rjsx-mode
        :after (js2-mode)
        :config
        (ejh/less-annoying-js2) ; `rjsx-mode' is based on `js2-mode'
        :commands (rjsx-mode))

      (use-package coffee-mode
        :commands (coffee-mode)
        :config
        (setq coffee-tab-width 2)
        (let ((case-fold-search t))
          (font-lock-add-keywords
           'coffee-mode
           ;; Class names
           '(("\\(\s\\|\\.\\)\\([A-Z][a-zA-Z]*\\)" 2 dired-marked-face)))))
    #+END_SRC

*** Kotlin
*** LaTeX
*** Lisp Family

    Lisps tend to share quite a bit between them. =paredit= for example is
    something that all of them would want.
    #+BEGIN_SRC emacs-lisp
      (use-package paredit
        :commands (paredit-mode)
        :diminish "[内]") ; "Inside"
    #+END_SRC

**** Clojure / ClojureScript

     While I've not had nearly enough time to work with it, I've *loved* what
     I've seen of Clojure so far.
     #+BEGIN_SRC emacs-lisp
       (use-package clojure-mode
         :init
         (add-hook 'clojure-mode-hook #'paredit-mode)
         (add-hook 'clojure-mode-hook 'clojure-mode-extra-font-locking)
         :config
         (add-to-list 'auto-mode-alist '("\\.edn$"    . clojure-mode))
         (add-to-list 'auto-mode-alist '("\\.boot$"   . clojure-mode))
         (add-to-list 'auto-mode-alist '("\\.cljs.*$" . clojure-mode))
         :commands (clojure-mode))

       (use-package clojure-mode-extra-font-locking
         :after (clojure-mode))

       (use-package cider
         :after (clojure-mode)
         :init
         (add-hook 'cider-repl-mode-hook 'paredit-mode)
         :config
         (setq cider-repl-pop-to-buffer-on-connect t
               cider-show-error-buffer t
               cider-auto-select-error-buffer t
               cider-repl-history-file "~/.emacs.d/cider-history"
               cider-repl-wrap-history t))
     #+END_SRC

**** Common Lisp
**** Emacs Lisp

     It should come as no surprise that I write a fair amount of this
     #+BEGIN_SRC emacs-lisp
       (use-package elisp-mode
         :init (add-hook 'emacs-lisp-mode-hook #'paredit-mode)
         :ensure nil ; necessary for a built-in
         :general
         (:prefix ejh/local-leader-key
          "e" '(nil :which-key "evaluate")
          "eb" '(eval-buffer :which-key "buffer")
          "er" '(eval-region :which-key "region")))
     #+END_SRC

**** Racket
**** Scheme
*** Lua

    #+BEGIN_SRC emacs-lisp
      (use-package lua-mode
        :init (add-hook 'lua-mode-hook
                        (lambda ()
                          (stupid-indent-mode +1) ; Emacs *really* struggles with Lua
                          (smartparens-mode)
                          (setq-local company-backends
                                      (ejh/yasnippetify-backends '(company-lua
                                                                   company-capf
                                                                   company-files
                                                                   company-dabbrev)))
                          (setq-local stupid-indent-level 2))))

      (use-package company-lua
        :after (lua-mode))
    #+END_SRC

*** Markdown

    I thought that this was really just a syntax package but ~markdown-mode~
    adds a whole bunch of ~org-mode~ like features like folding headings and
    such. I was sort of blown away by how much cool stuff is packed into this
    mode.
    #+BEGIN_SRC emacs-lisp
      (use-package markdown-mode
        :config
        (setq fill-column 80)
        (if ejh/can-spellcheck-p
            (flyspell-mode +1))
        (auto-fill-mode +1))
    #+END_SRC

*** Nim

    Haven't payed much attention to this. Has a sort of Python-y syntax if I
    remember correct. Kinda interesting. I might look at it more in the future.
    #+BEGIN_SRC emacs-lisp
      (use-package nim-mode
        :config
        (add-hook 'nim-mode-hook 'stupid-indent-mode))
    #+END_SRC

*** Nix
*** OCaml
*** Org

    Along with =magit=, =org-mode= is a huge selling point for Emacs. I'm
    obviously partial because this config is written in it.
    #+BEGIN_SRC emacs-lisp
      (add-hook 'org-mode-hook
                (lambda ()
                  (setq fill-column 80
                        org-src-fontify-natively t)
                  (if ejh/can-spellcheck-p
                      (flyspell-mode +1))
                  (flycheck-mode +1)
                  (auto-fill-mode +1)))
    #+END_SRC

*** PHP
*** Perl
*** PureScript

    Would love to give PureScript the time of day sometime, especially now that
    Elm is going down a path I'm not as interested in.
    #+BEGIN_SRC emacs-lisp
      (use-package purescript-mode
        :init (add-hook 'purescript-mode 'turn-on-purescript-indentation))
    #+END_SRC

*** Python
*** R

    There's actually a whole package called =ess= for "Emacs Speaks
    Statistics". I haven't had a chance too look too deeply at it, partially
    because I don't have a need to do statistics atm. But it looks so cool!
#+BEGIN_SRC emacs-lisp
  (use-package ess ; This contains `R-mode' among others
    :ensure t)
#+END_SRC

*** Ruby

    My day job was working on a pretty large Rails app for a few years. So
    naturally this was one of the first sections that had a lot going on in
    it. And this isn't even all of it, I know there were some other experimental
    files that I haven't moved into here, or plugins I had installed but didn't
    write down in this config.
    #+BEGIN_SRC emacs-lisp
      (use-package enh-ruby-mode
        :commands (enh-ruby-mode)
        :config
        ;; NOTE: This could probably be turned into a `:mode' here in `use-package'.
        ;; However, I'm not positive this works that well right now. I think it's just
        ;; a copy-paste from Stack Overflow.
        (add-to-list 'auto-mode-alist
                     '("\\(?:\\.rb\\|ru\\|rake\\|thor\\|jbuilder\\|gemspec\\|prodspec\\|/\\(?:Gem\\|Rake\\|Cap\\|Thor\\|Vagrant\\|Guard\\|Pod\\)file\\)\\'" . enh-ruby-mode))
        (let ((case-fold-search t))
          (font-lock-add-keywords
           'enh-ruby-mode
           '(("\s\\(sidekiq_options\\)" 1 font-lock-builtin-face)))))

      (use-package robe
        :after (enh-ruby-mode)
        :commands (robe-start robe-mode))

      (use-package rspec-mode
        :after (enh-ruby-mode)
        :commands (rspec-mode))

      (use-package rinari
        :diminish "[リ]" ; "Ri"
        :after (enh-ruby-mode)
        :commands (rinari-minor-mode))

      (use-package rvm
        :defer t)
    #+END_SRC

*** Rust

    On my infinitely growing list of "Languages that look cool and I want to
    learn". Maybe one day..
    #+BEGIN_SRC emacs-lisp
      (use-package rust-mode
        :commands (rust-mode)
        :init
        (add-hook 'rust-mode-hook
                  (lambda ()
                    (setq-local company-backends
                                (ejh/yasnippetify-backends '(company-racer
                                                             company-capf
                                                             company-dabbrev
                                                             company-files)))
                    ;; Without calling this, There will be issues with the
                    ;; `rust-cargo' checker.
                    (flycheck-rust-setup)
                    (smartparens-mode +1)
                    (flycheck-mode +1)
                    (racer-mode +1))))

      (use-package racer
        :after rust-mode
        :config
        (add-hook 'racer-mode-hook #'eldoc-mode))

      (use-package company-racer
        :after '(company racer rust-mode))

      (use-package flycheck-rust
        :after '(flycheck rust-mode))
    #+END_SRC

*** Scala

    I like what I've seen of Scala so far. "Functional Programming in Scala" is
    really what made a lot of Functional Programming concepts click for me. I'd
    like to get back to working with it.
    #+BEGIN_SRC emacs-lisp
      (use-package scala-mode
        :commands (scala-mode))
    #+END_SRC

*** Standard ML
*** Text

    ~text-mode~ is kind of a default for when you have to type something that
    isn't strictly related to a particular programming language. It handles
    typing commit messages in ~magit~ for example.
    #+BEGIN_SRC emacs-lisp
      (if ejh/can-spellcheck-p
          (add-hook 'text-mode-hook 'flyspell-mode))
    #+END_SRC

*** TypeScript

    Started doing more with TypeScript, mostly through Angular, and I really
    like it. Hoping to be able to do more with it in the future.
    #+BEGIN_SRC emacs-lisp
      (use-package typescript-mode
        :mode "\\.ts\\'"
        :commands (typescript-mode)
        :config
        (let ((case-fold-search t))
          (font-lock-add-keywords
           'typescript-mode
           ;; decorators
           '(("\s?\\(@[A-Za-z]*\\)"                1 font-lock-warning-face)
             ;; class names
             ("\\(\s\\|\\.\\)\\([A-Z][a-zA-Z]*\\)" 2 font-lock-type-face)
             ;; keys in objects
             ("\\(?:^\\s *\\|[[{(,]\\s *\\|\\sw\\s +\\)\\(\\(\\sw\\|_\\)+:\\)[^\\??:]"
              1 (progn
                  (forward-char -1)
                  font-lock-constant-face))))
          (add-hook
           'typescript-mode-hook
           '(lambda ()
              (tide-setup)
              (smartparens-mode +1)
              (flycheck-mode +1)
              (eldoc-mode +1)
              (tide-hl-identifier-mode +1)))))

      (use-package tide
        :after (typescript-mode)
        :ensure t)
    #+END_SRC

*** Vim Script

    This is honestly a little silly, but why leave Emacs?
    #+BEGIN_SRC emacs-lisp
      (use-package vimrc-mode
        :mode "\\(?:\\.vimrc\\|.vim\\)\\'"
        :commands (vimrc-mode))
    #+END_SRC

*** Vue
*** Web

    This is a space for =web-mode=, or anything else generically web related.
    #+BEGIN_SRC emacs-lisp
      (use-package web-mode
        :commands (web-mode))
    #+END_SRC

